#!/bin/bash

# Run this script to generate hashes for every file in a directory tree:
#    gird ~/Photos
# Each directory will now have a file named Girdsums in it.
#
# Run gird again to verify the hashes and ensure the directory contents haven't changed.
# Gird will not modify an existing Girdsums file unless forced.
#
# We compute the checksums for the files in this directory
#   If there's an existing checksums file
#     Then compare it to the new checksums
#       If the directory contents are different, PRINT A PANIC
#       If any file digests have changed, PRINT A PANIC

gird_directory () {
  die () {
    echo "$@" >&2
    if [ -z "$should_continue" ]; then
      kill $ogpid
      exit 255 # 255 tells xargs to quit immediately
    else
      exit 0
    fi
  }

  local path="$1"
  cd "$path"

  if [ -e Girdsums.inprogress ]; then
    die "$path: Girdsums.inprogress already exists. Is another Gird running? Exiting."
  fi

  if [ "$mode" == initializing ] && [ -f Girdsums ]; then
    die "$path: existing Girdsums file"
  fi

  if [ "$mode" == verifying ] && [ ! -f Girdsums ]; then
    die "$path: missing Girdsums file"
  fi

  echo "$mode $path"
  # add the files in the current directory
  find . -type f -maxdepth 1 \
    -not -name Girdsums \
    -not -name Girdsums.inprogress \
    -not -name .DS_Store \
    -print0 | sort -z | xargs -0 shasum -a 1 | sed 's| ./| |' > Girdsums.inprogress
  # add Girdsums files in subdirectories
  for file in */Girdsums; do
    [ -e "$file" ] || continue # bash returns the unexpanded string when no files match
    shasum -a 1 "$file" >> Girdsums.inprogress
  done

  if [ -e Girdsums ]; then
    local differences="$(diff -u Girdsums Girdsums.inprogress)"
    rm Girdsums.inprogress
    if [ -n "$differences" ]; then
      die "$(
        echo "$path: gird verification failed:"
        echo "$differences" | grep '^[+-][0-9A-Fa-f]'
      )"
    fi
  else
    mv Girdsums.inprogress Girdsums
  fi
}
export -f gird_directory

process_path() {
  export should_continue
  export mode="$forcemode"
  if [ -z "$mode" ]; then
    if [ -f "$1/Girdsums" ]; then
      mode=verifying
    else
      mode=initializing
    fi
  fi

  set -o pipefail
  find "$1" -type d -d -print0 | xargs -0 -n1 -I{} bash -c 'gird_directory "$@"' _ {}
  local exit="$?"
  if [ "$exit" != '0' ]; then
    if [ -n "$should_continue" ]; then
      exit_value=1
    else
      exit "$exit"
    fi
  fi
}

# subprocesses kill the parent to abort
# unless we trap the signal, bash prints a process terminated warning
abort() {
  exit 1
}
trap abort TERM

export ogpid=$$ # to abort, kill this pid
let count=0
let exit_value=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    -i|--init) forcemode='initializing'; shift;;
    -s|--verify|--scan) forcemode='verifying'; shift;;
    -c|--continue) should_continue=1; shift;;
    # --pidfile=*) pidfile="${1#*=}"; shift 1;;
    # --pidfile) echo "$1 requires an argument" >&2; exit 1;;
    -*) echo "unknown option: $1" >&2; exit 1;;
    *) let count++; process_path "$1"; shift;;
  esac
done

if [ "$count" -eq 0 ]; then
  process_path '.'
fi

if [ -n "$exit_value" ]; then
  exit "$exit_value"
fi
