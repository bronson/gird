#!/bin/bash

# Run this script to generate sha1 checksums for every file in a directory tree:
#    gird ~/Photos
# Each directory will now have a file named Girdsums in it.
#
# Run gird again to verify the hashes and ensure the directory contents haven't changed.
# Gird will not modify an existing Girdsums file unless forced.

version=0.9

gird_help () {
cat <<EOL
usage: gird [--init|--verify|--reset] [--continue|--abort] [directory ...]
EOL
}

gird_directory () {
  die () {
    echo "$@" >&2
    if [ -z "$should_continue" ]; then
      exit 255 # 255 tells xargs to quit immediately
    else
      exit 0
    fi
  }

  local path="$1"
  cd "$path" 2>/dev/null || die "$path does not exist"

  if [ -e Girdsums-inprogress ]; then
    die "$path: Girdsums-inprogress already exists. Is another Gird running? Exiting."
  fi

  if [ "$mode" == initializing ] && [ -f Girdsums ]; then
    die "$path: existing Girdsums file"
  fi

  if [ "$mode" == verifying ] && [ ! -f Girdsums ]; then
    die "$path: missing Girdsums file"
  fi

  echo "$mode $path"
  # add the files in the current directory
  find . -type f -maxdepth 1 \
    -not -name Girdsums \
    -not -name Girdsums-inprogress \
    -not -name Girdsums-stderr \
    -not -name .DS_Store \
    -print0 | sort -z | xargs -0 shasum -a 1 | sed 's| ./| |' > Girdsums-inprogress
  # add Girdsums files in subdirectories
  for file in */Girdsums; do
    [ -e "$file" ] || continue # bash returns the unexpanded string when no files match
    shasum -a 1 -- "$file" >> Girdsums-inprogress
  done

  if [ "$mode" != 'resetting' ] && [ -e Girdsums ]; then
    local differences="$(diff -u Girdsums Girdsums-inprogress)"
    rm Girdsums-inprogress
    if [ -n "$differences" ]; then
      die "$(
        echo "$path: gird verification failed:"
        echo "$differences" | grep '^[+-][0-9A-Fa-f]'
      )"
    fi
  else
    mv Girdsums-inprogress Girdsums
  fi
}
export -f gird_directory

# pass a command's exit code as an arg and its stderr in Girdsums-stderr file
# this function obeys the user's preference as to whether we abort immediately or keep running
detect_abort() {
  local exitcode="$1"
  local girderr="$([ -s Girdsums-stderr ] && echo yes)"
  cat Girdsums-stderr >&2
  rm Girdsums-stderr

  if [ "$exitcode" != '0' ] || [ -n "$girderr" ]; then
    if [ -n "$should_continue" ]; then
      let err_count++
    else
      exit "$exitcode"
    fi
  fi
}

process_path() {
  export should_continue
  export mode="$forcemode"
  if [ -z "$mode" ]; then
    if [ -f "$1/Girdsums" ]; then
      mode=verifying
    else
      mode=initializing
    fi
  fi

  set -o pipefail
  # can't tell if subprocesses encountered errors so we save stderr and check for content there
  find "$1" -type d -d -print0 | xargs -0 -n1 -I{} bash -c 'gird_directory "$@"' _ {} 2>Girdsums-stderr
  detect_abort "$?"
}

reset_path() {
  # run in a subprocess because gird_directory changes directories
  (mode='resetting' gird_directory "$1" 2>Girdsums-stderr)
  detect_abort "$?"

  # also reset all girdsums files up to the root
  if [ -f "$1/../Girdsums" ]; then
    reset_path "$1/.."
  fi
}

arg_count=0 # number of arguments processed
err_count=0 # number of errors encountered (where --abort would exit immediately)
should_continue=1 # '' means abort if we find an error, '1' means keep processing
action='process'

while [ "$#" -gt 0 ]; do
  case "$1" in
    -i|--init) action='process' forcemode='initializing'; shift;;
    -s|--verify|--scan) action='process' forcemode='verifying'; shift;;
    -R|--reset) action='reset'; shift;;
    -1|--abort) should_continue=; shift;;
    -c|--continue) should_continue=1; shift;;
    --version) echo "Gird $version"; exit;;
    -h|--help) gird_help; exit;;
    # --pidfile=*) pidfile="${1#*=}"; shift 1;;
    # --pidfile) echo "$1 requires an argument" >&2; exit 1;;
    -*) echo "unknown option: $1" >&2; exit 1;;
    *) let arg_count++; "${action}_path" "$1"; shift;;
  esac
done

if [ "$arg_count" -eq 0 ]; then
  "${action}_path" '.'
fi

if [ "$err_count" != '0' ]; then
  exit 1
fi
