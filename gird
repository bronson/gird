#!/bin/bash

# Run this script to generate hashes for every file in a directory tree:
#    gird ~/Photos
# Each directory will now have a file named Girdsums in it.
#
# Run gird again to verify the hashes and ensure the directory contents haven't changed.
# Gird will not modify an existing Girdsums file unless forced.
#
# We compute the checksums for the files in this directory
#   If there's an existing checksums file
#     Then compare it to the new checksums
#       If the directory contents are different, PRINT A PANIC
#       If any file digests have changed, PRINT A PANIC

gird_directory () {
  local path="$1"

  if [ -e Girdsums.inprogress ]; then
    echo "$path: Girdsums.inprogress already exists. Is another Gird running? Exiting." >&2
    kill $ogpid
    exit
  fi

  if [ "$mode" == init ] && [ -f Girdsums ]; then
    echo "$path: existing Girdsums file" >&2
    kill $ogpid
    exit
  fi

  if [ "$mode" == verify ] && [ ! -f Girdsums ]; then
    echo "$path: missing Girdsums file" >&2
    kill $ogpid
    exit
  fi

  echo "processing $path"
  # add the files in the current directory
  find . -type f -maxdepth 1 \
    -not -name Girdsums \
    -not -name Girdsums.inprogress \
    -not -name .DS_Store \
    -print0 | sort -z | xargs -0 shasum -a 1 | sed 's| ./| |' > Girdsums.inprogress
  # add Girdsums files in subdirectories
  for file in */Girdsums; do
    [ -e "$file" ] || continue # bash returns the unexpanded string when no files match
    shasum -a 1 "$file" >> Girdsums.inprogress
  done

  if [ -e Girdsums ]; then
    local differences="$(diff -u Girdsums Girdsums.inprogress)"
    rm Girdsums.inprogress
    if [ -n "$differences" ]; then
      echo "$path: gird verification failed:" >&2
      echo "$differences" | grep '^[+-][0-9A-Fa-f]' >&2
      kill $ogpid
      exit
    fi
  else
    mv Girdsums.inprogress Girdsums
  fi
}
export -f gird_directory

process_path() {
  find "$1" -type d -d -print0 | xargs -0 -n1 -I{} sh -c 'cd "{}" && gird_directory "{}"'
}

# subprocesses kill the parent to abort
# unless we trap the signal, bash prints a process terminated warning
abort() {
  exit 1
}
trap abort TERM

export ogpid=$$ # to abort, kill this pid
export mode='run'
let count=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    -i|--init) mode='init'; shift;;
    -s|--verify|--scan) mode='verify'; shift;;
    # -v|--verbose)
    # --version)
    # --pidfile=*) pidfile="${1#*=}"; shift 1;;
    # --pidfile) echo "$1 requires an argument" >&2; exit 1;;
    -*) echo "unknown option: $1" >&2; exit 1;;
    *) let count++; process_path "$1"; shift;;
  esac
done

if [ "$count" -eq 0 ]; then
  process_path '.'
fi
